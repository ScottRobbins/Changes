import ArgumentParser
import Files
import Foundation
import Version
import Yams

struct ChangelogGenerator {
  private struct ReleaseEntry {
    let version: Version
    let entries: [ChangelogEntry]
  }

  func regenerateChangelogs() throws {
    guard
      let configString = try? Folder.current.file(named: ".changelog-manager.yml").readAsString()
    else {
      throw ValidationError("No config found.")
    }

    let decoder = YAMLDecoder()
    guard let config = try? decoder.decode(ChangelogManagerConfig.self, from: configString) else {
      throw ValidationError("Invalid config file format.")
    }

    let releaseEntries = try getReleaseEntries(decoder: decoder)
    let sortedReleaseEntries = releaseEntries.sorted { $0.version > $1.version }
    let unreleasedEntries = try getUnreleasedEntries(decoder: decoder)

    for file in config.files {
      try writeToChangelog(
        unreleasedEntries: unreleasedEntries,
        releaseEntries: sortedReleaseEntries,
        file: file
      )
    }
  }

  private func getReleaseEntries(decoder: YAMLDecoder) throws -> [ReleaseEntry] {
    var releaseEntries = [ReleaseEntry]()
    var error: Error?
    let queue = DispatchQueue(
      label: "com.swiftbuildtools.changelog-manager.thread-safe-array",
      qos: .userInitiated,
      attributes: .concurrent
    )
    let group = DispatchGroup()
    let releaseFolders = try Folder.current.createSubfolderIfNeeded(
      at: ".changelog-manager/releases"
    ).subfolders

    for releaseFolder in releaseFolders {
      DispatchQueue.global(qos: .userInitiated).async(group: group) {
        do {
          let version = try Version(releaseFolder.name)
          let entries = try self.changelogEntries(
            folder: releaseFolder.createSubfolderIfNeeded(at: "entries"),
            decoder: decoder
          )

          queue.sync(flags: .barrier) {
            releaseEntries.append(.init(version: version, entries: entries))
          }
        }
        catch let e {
          queue.sync(flags: .barrier) {
            error = e
          }
        }
      }
    }

    group.wait()

    if let error = error {
      throw error
    }

    return releaseEntries
  }

  private func getUnreleasedEntries(decoder: YAMLDecoder) throws -> [ChangelogEntry] {
    let unreleasedFolder = try Folder.current.createSubfolderIfNeeded(
      at: ".changelog-manager/Unreleased"
    )
    return try changelogEntries(folder: unreleasedFolder, decoder: decoder)
  }

  private func changelogEntries(folder: Folder, decoder: YAMLDecoder) throws -> [ChangelogEntry] {
    return try folder.files.map { file in
      let fileString = try file.readAsString()
      return try decoder.decode(ChangelogEntry.self, from: fileString)
    }
  }

  private func writeToChangelog(
    unreleasedEntries: [ChangelogEntry],
    releaseEntries: [ReleaseEntry],
    file: ChangelogManagerConfig.ChangelogFile
  ) throws {
    let unreleasedContentString = sectionString(
      name: "Unreleased",
      entries: unreleasedEntries,
      file: file
    )

    let releaseContentString = releaseEntries.map { releaseEntry in
      sectionString(
        name: releaseEntry.version.description,
        entries: releaseEntry.entries,
        file: file
      )
    }.joined(separator: "\n\n\n")

    let changelogString =
      """
      # Changelog

      This file is auto-generated by ChangelogManager. Any modifications made to it will be overwritten


      \(unreleasedContentString)


      \(releaseContentString)
      """.trimmingCharacters(in: .whitespacesAndNewlines) + "\n"

    try Folder.current.createFileIfNeeded(at: file.path).write(changelogString)
  }

  private func sectionString(
    name: String,
    entries: [ChangelogEntry],
    file: ChangelogManagerConfig.ChangelogFile
  ) -> String {
    let validEntries = entries.filter { file.tags.contains($0.tag) }
    let usedTags = validEntries.map(\.tag).uniqueValues().sorted {
      if let index1 = file.tags.firstIndex(of: $0),
        let index2 = file.tags.firstIndex(of: $1)
      {
        return index1 < index2
      }
      else {
        return false
      }
    }

    let tagsString: String = usedTags.map { usedTag in
      let entriesString =
        validEntries
        .filter { $0.tag == usedTag }
        .sorted {
          $0.createdAtDate < $1.createdAtDate
        }.map {
          "- \($0.description)"
        }.joined(separator: "\n")

      return """
        ### \(usedTag)

        \(entriesString)
        """
    }.joined(separator: "\n\n")

    return """
      ## \(name)

      \(tagsString)
      """
  }
}
